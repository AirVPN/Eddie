// <eddie_source_header>
// This file is part of Eddie/AirVPN software.
// Copyright (C)2014-2016 AirVPN (support@airvpn.org) / https://airvpn.org
//
// Eddie is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// Eddie is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with Eddie. If not, see <http://www.gnu.org/licenses/>.
// </eddie_source_header>

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Xml;
using Eddie.Core;

namespace Eddie.Platforms
{
	public class NetworkLockIptables : NetworkLockPlugin
	{
		private List<IpAddressRange> m_currentList = new List<IpAddressRange>();

		public override string GetCode()
		{
			return "linux_iptables";
		}

		public override string GetName()
		{
			return "Linux IPTables";
		}

		public override bool GetSupport()
		{
			if (Exec("iptables --version").IndexOf("iptables v") != 0)
				return false;

			if (Exec("iptables-save").IndexOf("# Generated by iptables-save v") != 0)
				return false;

			return true;
		}

		public string GetBackupPath(string ipVersion)
		{
			if (ipVersion == "4") // For compatibility with Eddie<2.9
				ipVersion = "";
			return Storage.DataPath + Platform.Instance.DirSep + "ip" + ipVersion + "tables.dat";
		}

		public override void Activation()
		{
			base.Activation();

			string rulesBackupSessionV4 = GetBackupPath("4");

			if (File.Exists(rulesBackupSessionV4))
			{
				Engine.Instance.Logs.Log(LogType.Warning, Messages.NetworkLockUnexpectedAlreadyActive);
				Deactivation();
			}

			string rulesBackupSessionV6 = GetBackupPath("6");

			if (File.Exists(rulesBackupSessionV6))
			{
				Engine.Instance.Logs.Log(LogType.Warning, Messages.NetworkLockUnexpectedAlreadyActive);
				Deactivation();
			}

			// Backup V4
			Exec("iptables-save >\"" + rulesBackupSessionV4 + "\"");

			// Backup V6
			Exec("ip6tables-save >\"" + rulesBackupSessionV6 + "\"");

			// Flush V4
			Exec("iptables -F");
			Exec("iptables -t nat -F");
			Exec("iptables -t mangle -F");

			// Flush V6
			Exec("ip6tables -F");
			Exec("ip6tables -t nat -F");
			Exec("ip6tables -t mangle -F");

			// Local V4
			Exec("iptables -A INPUT -i lo -j ACCEPT");
			Exec("iptables -A OUTPUT -o lo -j ACCEPT");

			// Local V6
			Exec("ip6tables -A INPUT -i lo -j ACCEPT");
			Exec("ip6tables -A OUTPUT -o lo -j ACCEPT");

			// Make sure you can communicate with any DHCP server
			Exec("iptables -A OUTPUT -d 255.255.255.255 -j ACCEPT");
			Exec("iptables -A INPUT -s 255.255.255.255 -j ACCEPT");

			if (Engine.Instance.Storage.GetBool("netlock.allow_private"))
			{
				// Make sure that you can communicate within your own private networks
				Exec("iptables -A INPUT -s 192.168.0.0/16 -d 192.168.0.0/16 -j ACCEPT");
				Exec("iptables -A OUTPUT -s 192.168.0.0/16 -d 192.168.0.0/16 -j ACCEPT");
				Exec("iptables -A INPUT -s 10.0.0.0/8 -d 10.0.0.0/8 -j ACCEPT");
				Exec("iptables -A OUTPUT -s 10.0.0.0/8 -d 10.0.0.0/8 -j ACCEPT");
				Exec("iptables -A INPUT -s 172.16.0.0/12 -d 172.16.0.0/12 -j ACCEPT");
				Exec("iptables -A OUTPUT -s 172.16.0.0/12 -d 172.16.0.0/12 -j ACCEPT");

                // Multicast
                Exec("iptables -A OUTPUT -s 192.168.0.0/16 -d 224.0.0.0/24 -j ACCEPT");
                Exec("iptables -A OUTPUT -s 192.168.0.0/16 -d 224.0.0.0/24 -j ACCEPT");
                Exec("iptables -A OUTPUT -s 192.168.0.0/16 -d 224.0.0.0/24 -j ACCEPT");

                // 239.255.255.250  Simple Service Discovery Protocol address
                Exec("iptables -A OUTPUT -s 192.168.0.0/16 -d 239.255.255.250/32 -j ACCEPT");
                Exec("iptables -A OUTPUT -s 192.168.0.0/16 -d 239.255.255.250/32 -j ACCEPT");
                Exec("iptables -A OUTPUT -s 192.168.0.0/16 -d 239.255.255.250/32 -j ACCEPT");

                // 239.255.255.253  Service Location Protocol version 2 address
                Exec("iptables -A OUTPUT -s 192.168.0.0/16 -d 239.255.255.253/32 -j ACCEPT");
                Exec("iptables -A OUTPUT -s 192.168.0.0/16 -d 239.255.255.253/32 -j ACCEPT");
                Exec("iptables -A OUTPUT -s 192.168.0.0/16 -d 239.255.255.253/32 -j ACCEPT");
            }

			if (Engine.Instance.Storage.GetBool("netlock.allow_ping"))
			{
				// Allow incoming pings (can be disabled)
				Exec("iptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPT");
			}

			// Allow established sessions to receive traffic: 
			Exec("iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT");

			// Allow TUN 
			Exec("iptables -A INPUT -i tun+ -j ACCEPT");
			Exec("iptables -A FORWARD -i tun+ -j ACCEPT");
			Exec("iptables -A OUTPUT -o tun+ -j ACCEPT");

			// Block All V4
			Exec("iptables -A OUTPUT -j DROP");
			Exec("iptables -A INPUT -j DROP");
			Exec("iptables -A FORWARD -j DROP");

			// Block All V6
			Exec("ip6tables -A OUTPUT -j DROP");
			Exec("ip6tables -A INPUT -j DROP");
			Exec("ip6tables -A FORWARD -j DROP");

			OnUpdateIps();
			
		}

		public override void Deactivation()
		{
			base.Deactivation();

			// IPV4
			string rulesBackupSessionV4 = GetBackupPath("4");

			if (File.Exists(rulesBackupSessionV4))
			{
				// Flush
				Exec("iptables -F");
				Exec("iptables -t nat -F");
				Exec("iptables -t mangle -F");

				// Backup
				Exec("iptables-restore <\"" + rulesBackupSessionV4 + "\"");

				File.Delete(rulesBackupSessionV4);
			}

			// IPV6
			string rulesBackupSessionV6 = GetBackupPath("6");

			if (File.Exists(rulesBackupSessionV6))
			{
				// Flush
				Exec("ip6tables -F");
				Exec("ip6tables -t nat -F");
				Exec("ip6tables -t mangle -F");

				// Backup
				Exec("ip6tables-restore <\"" + rulesBackupSessionV6 + "\"");

				File.Delete(rulesBackupSessionV6);
			}

			// IPS
			m_currentList.Clear();
		}

		public override void OnUpdateIps()
		{
			base.OnUpdateIps();

			List<IpAddressRange> ipsFirewalled = GetAllIps(true);

			// Remove IP not present in the new list
			foreach (IpAddressRange ip in m_currentList)
			{
				if(ipsFirewalled.Contains(ip) == false)
				{
					// Delete
					string cmd = "iptables -D OUTPUT -d " + ip.ToCIDR() + " -j ACCEPT";
					Exec(cmd);
				}
			}

			// Add IP
			foreach (IpAddressRange ip in ipsFirewalled)
			{
				if (m_currentList.Contains(ip) == false)
				{
					// Add
					string cmd = "iptables -I OUTPUT 1 -d " + ip.ToCIDR() + " -j ACCEPT";
					Exec(cmd);
				}
			}

			m_currentList = ipsFirewalled;
		}
	}
}
